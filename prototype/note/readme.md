# 原型模式
> 原型模式是一种创建型设计模式， 使你**能够复制**已有对象， 而又无需使代码依赖它们所属的类。

## 问题
如果你有一个对象， 并希望生成与其完全相同的一个复制品， 你该如何实现呢？ 首先， 你必须新建一个属于相同类的对象。 然后， 你必须遍历原始对象的所有成员变量， 并将成员变量值复制到新对象中。

不错！ 但有个小问题。 并非所有对象都能通过这种方式进行复制， 因为有些对象可能拥有**私有成员变量**， 它们在对象本身以外是不可见的。

直接复制还有另外一个问题。 因为你必须知道对象所属的类才能创建复制品， 所以代码必须依赖该类。 即使你可以接受额外的依赖性， 那还有另外一个问题： 有时你只知道对象所实现的接口， 而不知道其所属的具体类， 比如可向方法的某个参数传入实现了某个接口的任何对象。

## 解决方案
原型模式将**克隆过程**委派给**被克隆的实际对象**。 模式为**所有支持克隆的对象声明了一个通用接口**， **该接口让你能够克隆对象， 同时又无需将代码和对象所属类耦合**。 通常情况下， 这样的接口中**仅包含一个 克隆方法**。

所有的类对 克隆方法的实现都非常相似。 **该方法会创建一个当前类的对象， 然后将原始对象所有的成员变量值复制到新建的类中**。 你甚至可以复制私有成员变量， 因为绝大部分编程语言都允许对象访问其同类对象的私有成员变量。

**支持克隆的对象即为原型**。 **当你的对象有几十个成员变量和几百种类型时， 对其进行克隆甚至可以代替子类的构造。**
> 其运作方式如下： 创建一系列不同类型的对象并不同的方式对其进行配置。 如果所需对象与预先配置的对象相同， 那么你只需克隆原型即可， 无需新建一个对象。

## 原型模式结构
1. 基本实现
![img.png](img.png)

2. 原型注册表实现
多加了一个switch-case的map的预复制表
![img_1.png](img_1.png)

## 适用场景
1. 如果你需要复制一些对象， 同时又希望代码独立于这些对象所属的具体类， 可以使用原型模式。
> 如果子类的区别仅在于其对象的初始化方式， 那么你可以使用该模式来减少子类的数量。 别人创建这些子类的目的可能是为了创建特定类型的对象。

2. 如果**子类的区别仅在于其对象的初始化方式**， 那么你可以使用该模式来减少子类的数量。 别人创建这些子类的目的可能是为了创建特定类型的对象。
> 在原型模式中， 你可以使用一系列预生成的、 各种类型的对象作为原型。客户端不必根据需求对子类进行实例化， 只需找到合适的原型并对其进行克隆即可。

## 实现方式
1. 创建原型接口， 并在其中声明 克隆方法。 如果你已有类层次结构， 则只需在其所有类中添加该方法即可。
2. 原型类必须另行定义一个**以该类对象为参数的构造函数**。 构造函数必须**复制参数对象中的所有成员变量值到新建实体中**。 如果你需要修改子类， 则必须调用父类构造函数， 让父类复制其私有成员变量值。
   如果编程语言不支持方法重载， 那么你可能需要定义一个特殊方法来复制对象数据。 在构造函数中进行此类处理比较方便， 因为它在调用 new运算符后会马上返回结果对象。

3. 克隆方法通常只有一行代码： 使用 new运算符调用原型版本的构造函数。 注意， 每个类都必须显式重写克隆方法并使用自身类名调用 new运算符。 否则， 克隆方法可能会生成父类的对象。
4. 你还可以创建一个中心化原型注册表， 用于存储常用原型。
   你可以新建一个工厂类来实现注册表， 或者在原型基类中添加一个获取原型的静态方法。 该方法必须能够根据客户端代码设定的条件进行搜索。 搜索条件可以是简单的字符串， 或者是一组复杂的搜索参数。 找到合适的原型后， 注册表应对原型进行克隆， 并将复制生成的对象返回给客户端。
   最后还要将对子类构造函数的直接调用替换为对原型注册表工厂方法的调用。

## 优缺点
### 优点
1. 你可以克隆对象， 而无需与它们所属的具体类相耦合。
2. 你可以克隆预生成原型， 避免反复运行初始化代码。
3. 你可以更方便地生成复杂对象。
4. 你可以用继承以外的方式来处理复杂对象的不同配置。
### 缺点
1. 克隆包含循环引用的复杂对象可能会非常麻烦。

## 与其他模式的关系
1. 原型可用于保存命令模式的历史记录。
2. 大量使用组合模式和装饰模式的设计通常可从对于原型的使用中获益。 你可以通过该模式来复制复杂结构， 而非从零开始重新构造。
3. 原型并不基于继承， 因此没有继承的缺点。 另一方面， 原型需要对被复制对象进行复杂的初始化。 工厂方法基于继承， 但是它不需要初始化步骤。
4. 有时候原型可以作为备忘录模式的一个简化版本， 其条件是你需要在历史记录中存储的对象的状态比较简单， 不需要链接其他外部资源， 或者链接可以方便地重建。


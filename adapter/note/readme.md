# 适配器模式
> **适配器模式**是一种结构型设计模式， 它能使接口不兼容的对象能够相互合作。
> 
> 适配器可担任两个对象间的封装器，它会接受对于一个对象的调用，并将其转换为另一个对象可识别的格式和接口
> 
> 适配器通过接口实现数据转换和解耦，或者实现公共子类的特殊方法的接口

## 问题
假如你正在开发一款股票市场监测程序， 它会从不同来源下载 XML 格式的股票数据， 然后向用户呈现出美观的图表。

在开发过程中， 你决定在程序中整合一个第三方智能分析函数库。 但是遇到了一个问题， 那就是分析函数库只兼容 JSON 格式的数据。
![img.png](img.png)
你可以修改程序库来支持 XML。 但是， 这可能需要修改部分依赖该程序库的现有代码。 甚至还有更糟糕的情况， 你可能根本没有程序库的源代码， 从而无法对其进行修改。

## 解决方案
你可以创建一个**适配器**。 这是一个特殊的对象， 能够**转换对象接口**， 使其**能与其他对象进行交互**。

适配器模式通过**封装对象****将复杂的转换过程隐藏于幕后**。 **被封装的对象甚至察觉不到适配器的存在**。 例如， 你可以使用一个将所有数据转换为英制单位 （如英尺和英里） 的适配器封装运行于米和千米单位制中的对象。

适配器不仅可以**转换不同格式的数据**， 其还有助于**采用不同接口的对象之间的合作**。 它的运作方式如下：
1. 适配器**实现与其中一个现有对象兼容的接口**。
2. 现有对象可以**使用该接口安全地调用适配器方法**。
3. 适配器方法被调用后**将以另一个对象兼容的格式和顺序**将请求传递给该对象。

有时你甚至可以创建一个双向适配器来实现双向转换调用。
![img_1.png](img_1.png)
让我们回到股票市场程序。 为了解决数据格式不兼容的问题， 你可以**为分析函数库中的每个类创建将 XML 转换为 JSON 格式的适配器**， 然后让**客户端仅通过这些适配器来与函数库进行交流**。 当某个适配器被调用时， 它会**将传入的 XML 数据转换为 JSON 结构**， 并将其传递给被封装分析对象的相应方法。

## 适配器模式结构
### 对象适配器
实现时使用了构成原则： **适配器实现了其中一个对象的接口**， **并对另一个对象进行封装**。 所有流行的编程语言都可以实现适配器。
![img_2.png](img_2.png)

### 类适配器
这一实现使用了继承机制： 适配器同时继承两个对象的接口。 请注意， 这种方式**仅能在支持多重继承的编程语言中实现**， 例如 C++。
![img_3.png](img_3.png)

## 适配器模式适合应用场景
1. 当你希望使用某个类， 但是其接口与其他代码不兼容时， 可以使用适配器类。(**解耦**)
> 适配器模式允许你**创建一个中间层类**， 其可作为代码与遗留类、 第三方类或提供怪异接口的类之间的转换器。
2. 如果您需要复用这样一些类， 他们处于同一个继承体系， 并且他们**又有了额外的一些共同的方法**， 但是这些共同的方法不是所有在这一继承体系中的子类所具有的共性。
>  你可以扩展每个子类， 将缺少的功能添加到新的子类中。 但是， 你必须在所有新子类中重复添加这些代码， 这样会使得代码有坏味道。
>
将缺失功能添加到一个适配器类中是一种优雅得多的解决方案。 然后你可以将缺少功能的对象封装在适配器中， 从而动态地获取所需功能。 如要这一点正常运作， **目标类必须要有通用接口**， **适配器的成员变量应当遵循该通用接口**。 这种方式同**装饰模式**非常相似。

## 实现方式
1. 确保至少有两个类的接口的不兼容
   - 一个无法修改(通常是第三方、遗留系统或者在众多已有依赖的类)的功能性**服务**类
   - 一个或多个收益于使用服务类的**客户端**类
2. 声明客户端接口，描述客户端如何与服务端交互
3. 创建遵循客户端接口的适配器类。 所有方法暂时都为空。
4. 在适配器类中**添加一个成员变量用于保存对于服务对象的引用**。 通常情况下会通过**构造函数**对该成员变量进行初始化， 但有时**在调用其方法时将该变量传递给适配器会更方便**。
5. 依次实现适配器类客户端接口的所有方法。适配器会**将实际工作委派给服务对象**，自身**只负责接口或数据格式的转换**。
6. 客户端必须**通过客户端接口使用适配器**。这样一来，你就可以在不影响客户端代码的情况下修改或拓展适配器。

## 优缺点
### 优点
- 单一职责原则，你可以讲接口或数据转换代码从程序主要业务逻辑中分离
- 开闭原则，只要客户端代码通过客户端接口和适配器进行交互，你就能在不修改现有客户端代码的情况在在程序中添加新类型的适配器

### 缺点
- 代码整体复杂度增加，因为你需要新增一系列接口和类。有时直接更改服务类使其与代码兼容会更简单~

## 与其他模式的关系
- **桥接模式**通常会于**开发前期进行设计**， 使你能够**将程序的各个部分独立开来以便开发**。 另一方面， **适配器模式**通常在已有程序中使用， 让相互不兼容的类能很好地合作。
- 适配器可以**对已有对象的接口进行修改**， **装饰模式**则能在不改变对象接口的前提下强化对象功能。 此外， **装饰还支持递归组合， 适配器则无法实现**。
- **适配器**能为被封装对象提供不同的接口， **代理模式**能为对象提供相同的接口， **装饰**则能为对象提供加强的接口。
- **外观模式**为现有对象定义了一个新接口， **适配器**则会试图运用已有的接口。 适配器通常只封装一个对象， 外观通常会作用于整个对象子系统上。
- 桥接、 状态模式和策略模式 （在某种程度上包括适配器） 模式的接口非常相似。 实际上， 它们都基于组合模式——即将工作委派给其他对象， 不过也各自解决了不同的问题。 模式并不只是以特定方式组织代码的配方， 你还可以使用它们来和其他开发者讨论模式所解决的问题。






# 单例模式
## 解决了什么问题
- 保证一个类只有一个实例
- 为该实例提供一个全局访问节点

## 解决方案
- 将默认构造函数设为私有，防止其他对象使用单例类的 `new`运算符
- 新建一个静态方法作为构造函数，该函数会调用私有构造函数来创建对象，并将其保存在一个静态成员变量中，此后所有`对于该函数的调用都将返回这一缓存对象`

## 适用场景
1. 如果程序中的某个类对于所有客户端只有一个可用的实例， 可以使用单例模式。
2. 如果你需要更加严格地控制全局变量， 可以使用单例模式。

## 实现方式
1. 在类中添加一个私有静态成员变量用于保存单例实例。
2. 声明一个公有静态构建方法用于获取单例实例。
3. 在静态方法中实现`延迟初始化(lazy)`。 该方法会在首次被调用时创建一个新对象， 并将其存储在静态成员变量中。 此后该方法每次被调用时都返回该实例。
4. 将类的构造函数设为私有。 类的静态方法仍能调用构造函数， 但是其他对象不能调用。
5. 检查客户端代码， 将对单例的构造函数的调用替换为对其静态构建方法的调用。

## 优点
1. 保证一个类只有一个实例
2. 获得了一个指向该实例的全局访问节点
3. 仅在首次请求单例对象时对其初始化

## 缺点
1. 违反了`单一职责`原则，该模式同时解决了两个问题
2. 单例模式可能掩盖不良设计，比如程序各组件之间相互了解过多
3. 该模式在多线程环境下需要进行特殊处理，避免多个线程多次创建单例对象

## 其他模式的联系
1. `外观模式`类通常可以转换为`单例模式`类，大部分情况下一个外观对象就足够了

2. 如果你能将对象的所有共享状态简化为一个享元对象， 那么享元模式就和单例类似了。 但这两个模式有两个根本性的不同。
- 只会有一个单例实体， 但是享元类可以有多个实体， 各实体的内在状态也可以不同。
- 单例对象可以是可变的。 享元对象是不可变的。
抽象工厂模式、 生成器模式和原型模式都可以用单例来实现